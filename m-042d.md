---
id: m-042d
status: open
deps: []
created: 2026-02-18T16:04:18Z
type: feature
priority: 0
assignee: Adam Avenir
tags: [sdk, elixir, beam]
updated: 2026-02-18T16:04:22Z
---
# Elixir SDK wrapper for mlld

# Elixir SDK Wrapper for mlld

## Why This Matters (Strategic Value)

George Guimarães's article "Your Agent Orchestrator Is Just a Bad Clone of Elixir" (georgeguimaraes.com) demonstrates that Python/TypeScript agent frameworks are reinventing patterns the BEAM VM solved in 1986. mlld takes a fundamentally different approach — it's a context engineering language, not an actor framework — which means mlld + Elixir is complementary, not redundant.

### The Insight

mlld handles the **what** (context composition, security labels, guard validation, pipeline retry). BEAM handles the **where** and **how many** (process isolation, supervision, scheduling, distribution). Together they answer every criticism from the article without either reinventing what the other already does.

### Why Elixir Is Not Just Another Wrapper

The existing SDK wrappers (Go, Python, Ruby, Rust) all fight their host language's concurrency model:

- **Go**: 900 lines of manual mutex/channel plumbing to fake what BEAM gives for free
- **Python**: Threading + queues to work around the GIL; no true process isolation
- **Ruby**: Similar threading limitations
- **Rust**: Great safety, but OS-level threads, no supervision trees

Elixir would be the **one SDK where the host language adds capabilities mlld can't provide on its own**:

| Capability | BEAM provides | Other SDKs must fake |
|---|---|---|
| One process per mlld execution | 2KB lightweight processes, millions concurrent | OS threads or async hacks |
| Supervision over executions | OTP supervisor restarts crashed mlld processes | Manual error handling, no structural recovery |
| Live transport via Port | Native Erlang Port wraps `mlld live --stdio` with backpressure | Subprocess management with manual I/O |
| Named agent discovery | Registry / :pg for finding running mlld agents | External infrastructure (Redis, etc.) |
| Demand-driven pipeline processing | GenStage/Flow for backpressure-aware fan-out of mlld results | Fixed concurrency caps |
| Real-time streaming to clients | Phoenix Channels streams mlld execution events to browsers | WebSocket libraries + custom plumbing |
| Hot config updates | Update which .mld scripts agents use without dropping connections | Full restart required |
| Distribution | Transparent cross-node mlld agent communication | External message queues |
| Per-process GC | No stop-the-world pauses across agents | Shared GC affects all connections |
| Preemptive scheduling | BEAM switches every 4000 reductions | Single-threaded event loops or manual yielding |

### The Pitch

An Elixir application running 10,000 concurrent mlld agents — each with its own supervised GenServer wrapping the live transport, each composing context through mlld's security-labeled pipelines, each independently checkpointed and resumable — is the production-grade agent platform that Guimarães argues for, without either technology having to reinvent the other.

---

## Feature Parity with Existing SDKs

The Elixir SDK must implement everything the Go/Python/Ruby/Rust wrappers provide. All wrappers use the same protocol: spawn `mlld live --stdio` and communicate via JSON-RPC over stdin/stdout.

### Core API (parity)

```elixir
# Client lifecycle
{:ok, client} = Mlld.Client.start_link(opts)
Mlld.Client.stop(client)

# Synchronous operations
{:ok, output} = Mlld.Client.process(client, script, opts)
{:ok, %Mlld.ExecuteResult{}} = Mlld.Client.execute(client, filepath, payload, opts)
{:ok, %Mlld.AnalyzeResult{}} = Mlld.Client.analyze(client, filepath)

# Async operations (return handles)
{:ok, handle} = Mlld.Client.process_async(client, script, opts)
{:ok, output} = Mlld.Handle.result(handle)
:ok = Mlld.Handle.cancel(handle)
:ok = Mlld.Handle.update_state(handle, path, value)
```

### Required Types (parity)

```elixir
defmodule Mlld.ExecuteResult do
  defstruct [:output, :state_writes, :exports, :effects, :metrics]
end

defmodule Mlld.AnalyzeResult do
  defstruct [:filepath, :valid, :errors, :executables, :exports, :imports, :guards, :needs]
end

defmodule Mlld.StateWrite do
  defstruct [:path, :value, :timestamp]
end

defmodule Mlld.Effect do
  defstruct [:type, :content, :security]
end

defmodule Mlld.Metrics do
  defstruct [:total_ms, :parse_ms, :evaluate_ms]
end

defmodule Mlld.Error do
  defexception [:message, :code]
end
```

### Required Options (parity)

```elixir
# ProcessOptions
%{
  file_path: String.t(),
  payload: term(),
  state: map(),
  dynamic_modules: map(),
  dynamic_module_source: String.t(),
  mode: :strict | :markdown,
  allow_absolute_paths: boolean(),
  timeout: pos_integer()
}

# ExecuteOptions — same minus file_path/script (filepath is a positional arg)

# ClientOptions
%{
  command: String.t(),          # default "mlld"
  command_args: [String.t()],   # e.g. ["./dist/cli.cjs"]
  timeout: pos_integer(),       # default 30_000
  working_dir: String.t()
}
```

### Required Protocol Features (parity)

- Live transport: spawn `mlld live --stdio`, read NDJSON from stdout, write JSON to stdin
- Request multiplexing: multiple in-flight requests with integer IDs
- Event dispatch: route `state:write` events to the correct in-flight handle
- Cancel support: send `{"method": "cancel", "id": N}` for in-flight requests
- State update: send `{"method": "state:update", ...}` with retry-on-REQUEST_NOT_FOUND
- Transport recovery: detect subprocess death, fail all pending requests, restart on next call
- Timeout handling: per-request timeouts with cancel-on-timeout

### Convenience module-level functions (parity)

```elixir
# Module-level convenience (uses a default supervised client)
Mlld.process(script, opts)
Mlld.execute(filepath, payload, opts)
Mlld.analyze(filepath)
```

### Integration tests (parity)

All existing SDKs have `live_integration_test` files. The Elixir SDK needs equivalent coverage.

---

## Elixir-Specific Features (Beyond Parity)

These features leverage BEAM capabilities that no other SDK wrapper can provide.

### 1. GenServer-based Client

The client should be a GenServer (not just a struct with a Port), enabling:
- Automatic transport restart via supervision
- Named registration for discovery
- Graceful shutdown with in-flight request draining

```elixir
# Supervised client
children = [
  {Mlld.Client, name: :main_agent, command: "mlld", timeout: 60_000}
]
Supervisor.start_link(children, strategy: :one_for_one)

# Use by name
Mlld.Client.process(:main_agent, script)
```

### 2. Supervisor Integration

Provide a supervisor module for managing pools of mlld agents:

```elixir
# Pool of 20 mlld agents with automatic restart
children = [
  {Mlld.Pool, name: :agent_pool, size: 20, overflow: 5}
]

# Execute against the pool (checks out an agent, returns it after)
Mlld.Pool.execute(:agent_pool, "pipeline.mld", payload)
```

### 3. Erlang Port (not os:cmd)

Use Erlang's Port for the live transport instead of System.cmd or a raw subprocess:
- Built-in backpressure (Port pauses when mailbox is full)
- Automatic cleanup when the owning process dies
- Binary mode for efficient I/O

### 4. Phoenix Channel Bridge

Optional integration module for streaming mlld events to Phoenix Channels:

```elixir
# In a Phoenix channel
def handle_in("execute", %{"filepath" => path, "payload" => payload}, socket) do
  Mlld.Phoenix.stream_execute(socket, path, payload, topic: "agent:results")
  {:noreply, socket}
end
```

This maps mlld SDK events (streaming:message, streaming:thinking, state:write) to Phoenix channel pushes.

### 5. Task-based Async

Leverage Elixir's Task module for async operations:

```elixir
# Fire-and-forget with supervision
task = Mlld.Client.execute_task(client, "pipeline.mld", payload)
result = Task.await(task, :infinity)

# Multiple concurrent executions
tasks = Enum.map(payloads, fn p ->
  Task.async(fn -> Mlld.Client.execute(client, "pipeline.mld", p) end)
end)
results = Task.await_many(tasks, 60_000)
```

### 6. Telemetry Integration

Emit `:telemetry` events for standard Elixir observability:

```elixir
# Automatically emitted
[:mlld, :execute, :start]    # %{filepath, payload_size}
[:mlld, :execute, :stop]     # %{duration, output_size}
[:mlld, :execute, :exception] # %{kind, reason}
[:mlld, :transport, :restart] # %{reason}
[:mlld, :cache, :hit]        # %{key}  (when checkpoint events flow through)
[:mlld, :cache, :miss]       # %{key}
```

### 7. Event Subscription via GenStage (optional)

For high-throughput scenarios, expose mlld events as a GenStage producer:

```elixir
# mlld execution produces events, downstream consumers process them
{:ok, producer} = Mlld.EventProducer.start_link(client)
{:ok, consumer} = MyConsumer.start_link(subscribe_to: [producer])
```

---

## Upcoming mlld Features That Impact SDK Shape

Three major features are planned but not yet prioritized. The Elixir SDK should be designed with these in mind, as they significantly expand the SDK surface area.

### A. Virtual Filesystem (spec-virtualfs.md)

A copy-on-write VFS that implements `IFileSystemService`. Scripts see a normal filesystem; writes go to a shadow layer. The backing store is never modified until explicitly flushed.

**SDK impact:**
- `execute()` and `processMlld()` will accept a `fileSystem` option
- `VirtualFS.empty()` (browser/isolated) and `VirtualFS.over(nodeFS)` (copy-on-write)
- New API surface: `changes()`, `flush()`, `discard()`, `export()`, `apply()`, `fileDiff()`
- VFS patches are serializable (`VFSPatch` type) — can be sent across the wire

**Elixir advantage:** A VFS per GenServer process means each agent has isolated filesystem state. BEAM process isolation maps perfectly to VFS isolation. The Elixir SDK could expose:

```elixir
# Each agent gets its own VFS
{:ok, agent} = Mlld.Agent.start_link(vfs: :empty)
Mlld.Agent.write_file(agent, "/template.md", content)
result = Mlld.Agent.execute(agent, "/run.mld", payload)
changes = Mlld.Agent.vfs_changes(agent)
Mlld.Agent.vfs_flush(agent)  # Apply to real FS

# Export VFS patch for review
patch = Mlld.Agent.vfs_export(agent)
# Apply another agent's patch
Mlld.Agent.vfs_apply(other_agent, patch)
```

This is the "agent sandbox" pattern — each BEAM process is a sandboxed agent with its own filesystem view. No other SDK can provide this naturally.

### B. Hooks, Checkpointing, and Resumable Execution (spec-hooks-checkpoints-resume.md)

Three composing features for resilience and observability:

1. **Hooks** — language-level directive for observing/modifying operations at evaluation boundaries. Like guards but for instrumentation. Error-isolated (hook failure never crashes pipeline).

2. **Checkpointing** — memoization of `llm`-labeled invocations to disk. `--checkpoint` flag. Cache key is `sha256(functionName + serializedArguments)`. Resume after crash without re-running completed LLM calls.

3. **Resumable execution** — `--resume @functionName` re-enters at a named function. `--resume @fn("pattern")` for fuzzy cursor into parallel iterations. Selective cache invalidation.

4. **Script forking** — `--fork <script>` loads another script's checkpoint cache. Pay for expensive LLM work once, branch into multiple analysis approaches.

**SDK impact:**
- New CLI flags: `--checkpoint`, `--fresh`, `--resume`, `--fork`
- New SDK options: `checkpoint: boolean`, `fresh: boolean`, `resume: string | true`, `fork: string`
- New context variables: `@mx.checkpoint.hit`, `@mx.checkpoint.key`, `@mx.hooks.errors`, `@mx.for.index/total/key/parallel`
- New SDK events: checkpoint hit/miss, hook errors
- New CLI subcommands: `mlld checkpoint list|inspect|clean`
- CheckpointManager as a new service on Environment

**Elixir advantage:** Checkpointing + supervision is the killer combination. A supervised mlld agent that crashes mid-pipeline:
1. Supervisor detects the crash
2. Restarts the agent GenServer
3. Agent re-runs with `--checkpoint` (or `--resume`)
4. Previously completed LLM calls resolve from cache
5. Pipeline continues from where it left off

This is exactly Guimarães's "let it crash" philosophy applied to LLM workflows — but with mlld's checkpoint system providing the semantic recovery that BEAM's process restart alone can't.

```elixir
# Supervised agent with automatic checkpoint recovery
defmodule MyAgent do
  use Mlld.Agent, restart: :permanent, checkpoint: true

  def run(payload) do
    execute("pipeline.mld", payload, checkpoint: true)
  end
end

# If the agent crashes, supervisor restarts it.
# Checkpoint cache means completed LLM calls are instant on retry.
# The 30-minute pipeline resumes in seconds.
```

Script forking maps to Elixir's process model: fork a checkpoint from one agent to spawn multiple analysis agents, each in their own supervised process:

```elixir
# One expensive collection run
{:ok, collector} = Mlld.Agent.start_link(script: "collect.mld", checkpoint: true)
Mlld.Agent.run(collector, payload)

# Fork into parallel analysis branches — each gets its own process
for variant <- ["v1", "v2", "v3"] do
  Task.async(fn ->
    {:ok, analyzer} = Mlld.Agent.start_link(
      script: "analyze-#{variant}.mld",
      fork: "collect"
    )
    Mlld.Agent.run(analyzer, payload)
  end)
end
```

### C. Combined Vision

With all three features, the Elixir SDK becomes a full agent platform:

- **VFS** = each agent has sandboxed filesystem (BEAM process isolation)
- **Hooks** = structured telemetry via `:telemetry` (error-isolated, always-on observability)
- **Checkpointing** = crash recovery via supervision + cache (let it crash + resume)
- **Forking** = branching analysis via Task.async (pay once, analyze many ways)
- **Guards** = security enforcement (non-bypassable policy)
- **Streaming** = real-time updates via Phoenix Channels

This is the stack Guimarães argues for — but instead of rebuilding everything from scratch in Elixir, mlld provides the context engineering layer and Elixir provides the runtime.

---

## Acceptance Criteria

### Phase 1: Feature Parity
- [ ] Erlang Port-based live transport (spawn `mlld live --stdio`)
- [ ] GenServer client with automatic transport restart
- [ ] `process/2`, `execute/3`, `analyze/2` synchronous APIs
- [ ] `process_async/2`, `execute_async/3` returning Task-compatible handles
- [ ] `cancel/1`, `update_state/3` on handles
- [ ] All types: ExecuteResult, AnalyzeResult, StateWrite, Effect, Metrics, Error
- [ ] Request multiplexing with integer IDs
- [ ] Event dispatch (state:write routing)
- [ ] Per-request timeout with cancel
- [ ] Transport death detection and pending request failure
- [ ] Module-level convenience functions
- [ ] Integration test suite matching other SDKs
- [ ] Hex package published as `mlld`
- [ ] README with examples

### Phase 2: Elixir-Native Features
- [ ] Supervision tree integration (child_spec, start_link)
- [ ] Connection pool (Mlld.Pool) with checkout/checkin
- [ ] :telemetry event emission
- [ ] Phoenix Channel bridge module (optional dependency)
- [ ] Named registration and discovery

### Phase 3: Future Feature Readiness
- [ ] VFS integration when virtualfs lands (per-process sandboxed FS)
- [ ] Checkpoint/resume options passthrough when hooks-checkpoints-resume lands
- [ ] Supervised auto-recovery with checkpoint (let it crash + resume pattern)
- [ ] Fork support for branching analysis across processes
- [ ] Hook event forwarding to :telemetry

---

## File Structure

```
sdk/elixir/
  mix.exs
  lib/
    mlld.ex                    # Module-level convenience functions
    mlld/
      client.ex                # GenServer wrapping live transport
      handle.ex                # Async operation handle
      port.ex                  # Erlang Port management
      pool.ex                  # Connection pool supervisor
      protocol.ex              # JSON-RPC encode/decode
      types.ex                 # All struct definitions
      error.ex                 # MlldError exception
      telemetry.ex             # :telemetry event emission
  lib/mlld_phoenix/            # Optional Phoenix integration
    channel_bridge.ex
  test/
    mlld_test.exs
    mlld/client_test.exs
    live_integration_test.exs  # Parity with other SDKs
  README.md
```

