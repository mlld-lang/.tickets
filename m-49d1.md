---
id: m-49d1
status: closed
deps: []
created: 2026-02-16T17:08:00Z
type: bug
priority: 0
assignee: Adam
tags: [bug, interpreter, guards, p0, qa-driven]
updated: 2026-02-16T17:31:26Z
---
# bug: compound @mx expressions in guard conditions break denied handler dispatch

## Problem

When a guard condition uses a compound expression combining multiple `@mx` fields (e.g., `@mx.op.name == "deleteData" && @mx.tools.calls.includes("deleteData")`), and that guard denies, the denied handler in the calling exe does not catch the denial. Instead, a `MlldWhenExpression` error is thrown.

Simpler guard conditions (like just `@mx.tools.calls.length >= 3`) work fine with denied handlers.

## Repro

```mlld
guard @compoundGuard before op:exe = when [
  @mx.op.name == "deleteData" && @mx.tools.calls.includes("deleteData") => deny "Already deleted"
  * => allow
]

exe @deleteData() = run cmd { echo "deleting" }

exe @safeDelete() = when [
  denied => "blocked"
  * => @deleteData()
]

var @first = @safeDelete()
var @second = @safeDelete()
show @second
```

Expected: second call returns "blocked" via denied handler.
Actual: MlldWhenExpression error thrown, denied handler not invoked.

## Where to look

- `interpreter/eval/exec/guard-policy.ts` — `handleExecGuardDenial()` 
- `interpreter/eval/when.ts` — the when expression evaluator
- The error path when a guard with compound conditions denies — something in the when-expression evaluation is throwing before the denial reaches the denied handler dispatch

## Likely cause

The compound expression evaluation inside the guard's when block may be throwing a when-expression error that isn't recognized as a guard denial by `handleExecGuardDenial()`. The error type doesn't match what the denied handler dispatch expects.

## Source
QA run: qa/runs/2026-02-16-0/topics/tool-call-tracking/

