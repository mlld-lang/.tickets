---
id: m-88b6
status: open
deps: []
created: 2026-02-24T20:52:58Z
type: task
priority: 0
assignee: Adam Avenir
---
# Audit error enhancement patterns against current peggy output

## Summary

The error enhancement system (see `docs/dev/ERRORS.md`) pattern-matches on peggy.js parse error messages and replaces them with user-friendly alternatives. An audit found **27 of 37 parse error patterns are broken or unreachable**. Only 10 still work. All 6 JS runtime error patterns work fine.

The patterns must work in BOTH strict mode (no `/` prefix on directives) and markdown mode (`/` prefix on directives).

### Root Causes

1. **Slash removed from error messages**: Grammar was updated to say `"Invalid exe syntax"` instead of `"Invalid /exe syntax"`. 8+ patterns still match on the old `/exe`, `/var`, `/for` forms.
2. **Grammar now has its own error handlers**: Many errors now have dedicated `mlldError()` handlers in the grammar that fire before the enhancement system sees them.
3. **Strict/markdown mode mismatch**: Many patterns hardcode `^\/var\s+` regex which only works in markdown mode. Strict mode has no `/` prefix.
4. **mlldError vs SyntaxError properties**: Custom `mlldError` objects lack the `expected` array and `found` string that some patterns check for.
5. **Test gap**: The fixture test runner verifies that invalid test cases throw errors but does NOT validate the actual error message against the `expectedError` field. The `toContain` assertion is gated behind `hasExpectedOutput && hasExpectedError`, and error fixtures typically have no expected output. So stale patterns break silently.

---

## Part 1: REMOVE these 18 patterns

Delete these pattern directories entirely. They are either shadowed by the grammar (grammar already gives a good error message), unreachable (the error condition no longer exists), or broken and redundant.

### Shadowed by grammar (grammar handles the error directly — pattern is unreachable)

| Pattern | Why remove |
|---------|-----------|
| `comment-in-array-literal` | Grammar now has `mlldError("Comments (>>) are not allowed inside array literals...")` |
| `comment-in-object-literal` | Grammar now has `mlldError("Comments (>>) are not allowed inside object literals...")` |
| `comment-in-when-array-exe` | Grammar handles when array comments directly |
| `comment-in-when-array-var` | Grammar handles when array comments directly |
| `comment-in-when-implicit` | Grammar handles when array comments directly |
| `when-comma-separated` | Grammar now has `"Comma separators are not allowed in when conditions..."` |
| `for-parallel-deprecated` | Grammar handles this via `helpers.warn()` in `iteration.peggy` |

### Unreachable (error condition no longer exists or caught by earlier pattern)

| Pattern | Why remove |
|---------|-----------|
| `for-loop-slash-rhs` | Checks for `"Unexpected '/' in for loop action"` which doesn't exist in grammar. The `rhs-slash` pattern already covers these cases. |
| `when-slash-rhs` | The `rhs-slash` pattern (sorted earlier) catches the same cases first. |
| `slash-in-action` | The `rhs-slash` pattern catches `/` before this pattern gets a chance. |
| `semver-quoted-version` | Grammar now parses `@author/module@"1.0.0"` as valid syntax — no error fires. |
| `policy-syntax` | Checks for error messages ('union', 'data object literal') that grammar no longer produces. |
| `pipeline-bare-braces-command` | Grammar's `InvalidBareCommandBrackets` handler fires first for bare `{`. |

### Broken and redundant

| Pattern | Why remove |
|---------|-----------|
| `exe-unnecessary-block` | Checks for `"Invalid /exe syntax"` but grammar now catches bare braces directly with its own helpful message. |
| `for-block-syntax` | Checks `"Invalid /var syntax"` for a for-loop issue — wrong error type entirely. |
| `var-nested-fields` | Regex `^\/var\s+@\w+\.` fails in strict mode, and grammar handles the error already. |
| `var-template` | Regex bug (`\b` before `=` never matches). The `template-outside-exe` pattern handles strict mode; fix that pattern to also handle markdown mode instead. |
| `bare-brace-command` | Overlaps with grammar's `InvalidBareCommandBrackets` handler which is more precise. |

---

## Part 2: FIX these 9 patterns

These patterns provide valuable enhanced error messages but have broken matching. For each, the fix is specified.

### Fix 1: Update error message matching (remove slash from expected message)

These 4 patterns check `error.message.includes('Invalid /xxx syntax')` but the grammar now says `'Invalid xxx syntax'` (no slash). Fix: remove the `/` from the expected message string.

| Pattern | Change |
|---------|--------|
| `exe-nested-fields` | `'Invalid /exe syntax'` → `'Invalid exe syntax'`. Also: the pattern checks `error.expected?.some(e => e.text === '=')` but `mlldError` objects have no `expected` array — remove that check. Also: regex `^\/exe\s+@\w+\.` → `^\/?exe\s+@\w+\.` for both modes. |
| `exe-run-sh` | `'Invalid /exe syntax'` → `'Invalid exe syntax'`. Also: fix any line-matching regex to handle both modes (`^\/?exe`). |
| `for-parallel-order` | `'Invalid /for syntax'` → `'Invalid for syntax'`. Also: fix line regex to handle both modes (`^\/?for`). |
| `output-missing-to-hint` | `"Missing 'to' keyword in /output directive"` → `"Missing 'to' keyword in output directive"`. |

### Fix 2: Update regex to handle both strict and markdown modes

These 5 patterns hardcode the `/` prefix in line-matching regex. Fix: make the slash optional with `\/?`.

| Pattern | Change |
|---------|--------|
| `var-with-parens` | `mx.line.startsWith('/var')` → `mx.line.match(/^\s*\/?var\s/)` |
| `import-wildcard` | `^\/import\s+\*` → `^\/?import\s+\*`. Also update the fallback check `mx.line.includes('/import')` → `mx.line.match(/\/?import/)`. |
| `run-missing-braces` | `^\/run\s+[^{"]` → `^\/?run\s+[^{"]` |
| `exe-block-when-confusion` | `mx.line.includes('/exe')` → `mx.line.match(/\/?exe/)` |
| `template-outside-exe` | `^\s*var\s+@\w+\s*=\s*template\s` → `^\s*\/?var\s+@\w+\s*=\s*template\s` (add `\/?` to also handle markdown mode) |

---

## Part 3: FIX the test gap

The fixture test runner (`interpreter.fixture.test.ts`) verifies that invalid test cases throw errors but does NOT validate the actual error message against the `expectedError` field. The `toContain` check is gated behind `hasExpectedOutput && hasExpectedError` — error fixtures typically have no expected output, so the message is never checked.

**Fix**: Change the gate condition so `expectedError` is checked whenever it's present, regardless of whether `expectedOutput` exists. This ensures error message regressions are caught by tests going forward.

---

## Part 4: KEEP these 10 working parse patterns + 6 JS patterns (no changes needed)

### Working parse patterns
`let-at-top-level`, `rhs-slash`, `slash-in-block-body`, `spread-operator-typo`, `needs-missing-braces`, `var-in-block`, `var-in-exe-block`, `env-as-expression`, `action-in-exe-when`, `pipeline-missing-at-prefix`

### Working JS patterns (all 6)
`at-sign-in-js`, `field-access-array`, `js-mutation-attempt`, `type-mismatch-field-access`, `type-mismatch-iteration`, `type-mismatch-method-call`

---

## Acceptance Criteria

- 18 dead patterns deleted
- 9 broken patterns fixed and verified working in both strict and markdown modes
- Test runner validates error messages (not just that an error was thrown)
- All remaining patterns have a passing test in both modes

