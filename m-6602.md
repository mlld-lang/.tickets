---
id: m-6602
status: open
deps: []
links: [m-29d1, m-46d6, m-fcc5]
created: 2026-02-09T06:18:30Z
type: feature
priority: 0
assignee: Adam Avenir
tags: [security, needs-human-design, core]
---
# Design: Operation limits in policy (call/cost budgets)

## Task

Design the operation limits feature for mlld's policy system. This is a DESIGN task — produce a spec section, not an implementation.

## Layer

Core engine.

## Problem

mlld's security thesis is that the execution layer enforces constraints the LLM cannot circumvent. Currently that layer checks WHAT can run (capabilities) but not HOW MUCH. A compromised LLM that calls a legitimate, policy-allowed operation in a loop — git status 10,000 times, 500 LLM API calls at $0.10 each — passes every capability and label check while burning real money and resources.

This is the only gap in the current model that enables a successful attack entirely through legitimate operations.

## Evidence

15+ defensive patterns across 8+ real-world AI agent repos (AutoGPT, smolagents, OpenHands, openclaw, llama_index, browser-use, langchain, MetaGPT) address rate limiting, token counting, LLM API quota enforcement, and concurrent request limits. It's the most common defensive concern after credential protection and input validation.

## Design Questions

1. **Scope of limits** — Per-exe, per-operation-label, per-capability pattern, or all three? E.g., should you be able to limit `exe:llm:*` separately from `op:cmd:git:*`?
2. **Limit dimensions** — Call count, token count, wall-clock time, estimated cost? Which are core vs. extension points?
3. **Time windows** — Per-run (natural for short-lived scripts), per-minute, per-hour? Does mlld need windowed counters or is per-run sufficient given scripts are invocations not daemons?
4. **Enforcement point** — Before operation (like capabilities), or tracked via audit ledger and checked pre-operation? The audit ledger already records every event, so counting could be a query over existing data.
5. **Policy syntax** — How does this integrate with the existing policy object? Strawman:
   ```mlld
   policy {
     limits: {
       "exe:llm:*": { calls: 100, cost: "$5.00" },
       "op:net:w": { calls: 50 },
       "op:cmd:*": { calls: 200 }
     }
   }
   ```
6. **Failure mode** — Hard deny? Warn-then-deny? Configurable? Should there be a guard hook for limit-exceeded events?
7. **Relationship to environment limits** — Environments already have `limits: { mem, cpu, timeout }`. Are operation limits a sibling concept in the same object, or a separate policy concern?
8. **Cost tracking** — If cost is a dimension, how are costs determined? Per-provider config? Callback to host application?

## Deliverable

A spec section (like the existing spec v4 parts) covering syntax, semantics, enforcement, and interaction with existing features (capabilities, guards, audit ledger, environments).

