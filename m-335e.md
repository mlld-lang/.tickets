---
id: m-335e
status: closed
deps: []
created: 2026-02-18T01:27:14Z
type: feature
priority: 0
assignee: Adam Avenir
tags: [security, guards, labels]
updated: 2026-02-18T06:48:06Z
---
# Bare guard labels match both data and operation indexes

Currently guard before LABEL (without op: prefix) only stores in dataIndex and only matches data labels on inputs. guard before op:TYPE stores in opIndex and matches operation keys (including exe labels).

This creates an ergonomic mismatch: you write exe exfil @postToSlack(msg) but must write guard before op:exfil to match it. The op: prefix is an implementation detail leaking into user syntax.

**Change:** Make bare-label guards also match operation labels (approach A from design discussion). When collectOperationGuards builds operation keys from exe opLabels, also check dataIndex for matches. The op: prefix becomes optional disambiguation syntax for operation-only matching.

**Key design decisions:**
- Bare labels match BOTH dataIndex and opIndex lookups
- op: prefix narrows to operation-only matching (power-user syntax)  
- When a bare-label guard fires via operation matching, use per-operation scope (array inputs)
- When same guard fires via data matching, use per-input scope (individual variable)
- Deduplication: if a guard already fired per-input, don't fire again per-operation in same hook

**Files to investigate:**
- grammar/directives/guard.peggy (GuardFilterClause, GuardDataFilter)
- interpreter/guards/GuardRegistry.ts (registerDefinition, opIndex vs dataIndex)
- interpreter/hooks/guard-candidate-selection.ts (collectOperationGuards, buildPerInputCandidates)
- interpreter/hooks/guard-operation-keys.ts (buildOperationKeys)

**Acceptance criteria:**
- guard before exfil fires when exe labeled exfil is called
- guard before op:exfil still works (operation-only)
- guard before secret still fires per-input for data with secret label
- guard before secret ALSO fires per-operation if an exe is labeled secret
- No double-firing of the same guard in one operation
- Existing tests pass


**2026-02-18 01:56 UTC:** ## Investigation Results (2026-02-17)

### Grammar: No changes needed
DataLabelIdentifier already accepts colon-namespaced labels (net:w, fs:w). Bare labels continue to parse as filterKind: 'data'. Change is purely runtime.

### Root cause
When exe labeled `exfil` runs, label goes into `operationContext.labels`. But `buildOperationKeys()` (guard-operation-keys.ts:26-95) only processes `operationContext.opLabels` (computed labels like op:cmd) and type/subtype. It never reads `operation.labels` (bare exe labels). So bare exe labels never become operation keys, and `collectOperationGuards` never finds data guards for them.

### Implementation plan — two changes required

**1. `buildOperationKeys()` in guard-operation-keys.ts**
Add `operation.labels` (bare exe labels) to the keys set. Currently only processes `opLabels` (lines 74-88). After line 88, iterate `operation.labels` and add each to the keys set.

**2. `collectOperationGuards()` in guard-candidate-selection.ts**
When iterating operation keys (lines 73-81), also query `registry.getDataGuardsForTiming(key, timing)` — not just `getOperationGuardsForTiming`. This ensures bare-label guards (stored in dataIndex) are found when exe labels are looked up as operation keys.

Step 1 ensures exe labels become operation keys. Step 2 ensures data-index guards are found for those keys.

### Scope handling
When a data guard fires via operation matching, it runs with perOperation scope (array @input with .any/.all/.none helpers). Correct because the match is on the operation, not a specific input.

### Cross-phase deduplication
If `guard before secret` matches both a data label on an input AND an operation label on the exe, it could fire twice — once per-input (from buildPerInputCandidates) and once per-operation (from collectOperationGuards). Fix: pass a shared `seen` set from guardPreHook to both functions, or filter out already-fired guard IDs before running operation guards.

### After guards
Same issue exists in executePostGuard (guard-post-orchestrator.ts) — it calls the same collectOperationGuards. Fixing collectOperationGuards fixes both before and after.

### Files to modify
- `interpreter/hooks/guard-operation-keys.ts` — add operation.labels to keys in buildOperationKeys()
- `interpreter/hooks/guard-candidate-selection.ts` — in collectOperationGuards, also query dataIndex for operation keys
- `interpreter/hooks/guard-pre-hook.ts` — pass shared seen set between buildPerInputCandidates and collectOperationGuards to prevent cross-phase double-fire

### Files unchanged
Grammar, GuardRegistry, serialization, guard-post-orchestrator (inherits fix via collectOperationGuards).

### New tests needed
- guard before exfil fires when exe labeled exfil is called
- guard before exfil doesn't double-fire when input also has exfil label
- guard before op:exfil still works (operation-only, unchanged)
- Multiple exe labels ([exfil, destructive]) both match their respective guards
- After-timing bare label guards work the same way
- Integration fixture: exe [exfil] @send(data) + guard before exfil => deny
