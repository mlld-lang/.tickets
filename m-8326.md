---
id: m-8326
status: closed
deps: [m-0558]
created: 2026-02-16T16:55:59Z
type: task
priority: 0
assignee: Adam
tags: [docs, security, p0, qa-driven]
updated: 2026-02-17T19:18:23Z
---
# Review all security examples: replace API key filtering with real prompt injection scenarios

## Problem

Security doc examples currently use API key filtering as the canonical example. Filtering API keys is architecturally trivial (regex, env var management). It undersells the actual hard problem that mlld's security system solves.

## What the examples should show instead

The hard problem: an LLM reads private/sensitive/proprietary data, then makes tool calls that could exfiltrate that data. Taint tracking + guards is the mechanism that catches this.

Example flow:
- Load proprietary data, label it (var proprietary @docs = <internal/*.md>)
- LLM processes the data (response now carries the proprietary taint)
- LLM attempts a tool call (eg write to external API, send email, post to webhook)
- Operation guard detects proprietary-labeled data flowing to an external operation
- Guard denies with clear reason
- Denied handler provides graceful fallback (summarize without quoting, strip sensitive sections, etc.)

## Scope

Review and update examples in all security atoms:
- security-getting-started.md (highest priority — first thing users see)
- before-guards.md
- after-guards.md
- denied-handlers.md
- guards-basics.md
- labels-overview.md
- label-tracking.md
- policy-label-flow.md
- Any other atom using API key / sk-12345 examples

Replace trivial API key examples with prompt injection defense scenarios that demonstrate why taint tracking matters. Keep examples realistic and grounded in the LLM orchestration use case.

## Depends on
m-0558 (security docs restructuring) should happen first or concurrently — no point updating examples into a structure that's about to change.

