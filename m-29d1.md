---
id: m-29d1
status: open
deps: []
links: [m-6602, m-46d6, m-fcc5]
created: 2026-02-09T06:19:10Z
type: feature
priority: 1
assignee: Adam Avenir
tags: [security, needs-human-design, core]
---
# Design: Network destination policy (SSRF defense)

## Task

Design network destination allowlisting/denylisting for mlld policy and environments. This is a DESIGN task — produce a spec section, not an implementation.

## Layer

Core engine (policy enforcement + environment config).

## Problem

Environments currently support `net: "none"` (full isolation) but the only alternative is full network access. Real deployments live in the middle: "network access, but only to these hosts" or "network access, but not to internal services." SSRF — tricking an agent into hitting internal services or cloud metadata endpoints — appeared across multiple real-world repos (haystack, crewAI, AutoGPT, dify).

The gap between net:none and unrestricted is where most production systems need to operate.

## Evidence

Multiple repos implement URL hostname validation, private IP blocking (RFC 1918, link-local, cloud metadata 169.254.169.254), and SSRF prevention at the application layer. crewAI has URL hostname validation via urlparse, haystack has SSRF protection patterns, AutoGPT has URL normalization.

## Design Questions

1. **Policy-level vs environment-level** — Should network restrictions exist only in environments, or also at the top-level policy? Non-sandboxed scripts also make network calls.
2. **Syntax** — Strawman:
   ```mlld
   net: {
     allow: ["api.github.com", "*.openai.com"],
     deny: ["private"]
   }
   ```
   Where `"private"` is a built-in token covering RFC 1918, link-local, cloud metadata.
3. **Built-in tokens** — What set of built-in deny tokens? `"private"` (RFC 1918 + link-local), `"metadata"` (169.254.169.254, GCP/Azure equivalents), `"localhost"`?
4. **Granularity** — Host-only? Host + port? Host + path? Full URL patterns? More granularity = more power but more complexity.
5. **DNS rebinding** — A host that resolves to a public IP at check time but a private IP at connection time. Does mlld need to re-check after DNS resolution? Or is this the environment provider's responsibility?
6. **Redirect following** — If an allowed host redirects to a denied host, should that be blocked? At what layer?
7. **Enforcement point** — Intercept at `net:w` and `net:r` operation labels? Or at a lower layer (environment provider)?
8. **Interaction with sealed credentials** — `using auth:X` injects credentials for specific services. Should the `net.allow` list be automatically derived from `auth` entries?

## Deliverable

A spec section covering syntax, built-in tokens, enforcement semantics, and interaction with environments, capabilities, and sealed credentials.

