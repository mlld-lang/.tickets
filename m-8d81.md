---
id: m-8d81
status: open
deps: []
links: [mlld-wmzl.12]
created: 2026-02-09T06:20:05Z
type: feature
priority: 3
assignee: Adam Avenir
tags: [security, needs-human-design, core]
---
# Design: Module signing and import verification

## Task

Design signing and verification for imported modules, especially those exporting privileged guards. This is a DESIGN task — produce a spec section, not an implementation.

## Layer

Core engine (extension of existing signing infrastructure).

## Problem

mlld has importable guard bundles: `import { @noSecretExfil } from "@company/security"`. Privileged guards can bless data — remove the untrusted label. If the module source is compromised, its exported privileged guards could bless anything, silently defeating the entire security model.

mlld already has signing for templates (SHA-256 content hashing, stored in .mlld/sec/sigs/). The mechanism exists; it just needs to apply to a new artifact type.

## Evidence

8+ supply chain security patterns across 5+ repos (openclaw, elizaOS, llama_index, langgraph, smolagents). Lockfile integrity hashes, lifecycle script suppression, pinned CI actions. The concern is universal: trust in imported code.

The huggingface/smolagents pattern for Python import allowlists is particularly relevant — deny-by-default module imports for security-critical code execution.

## Design Questions

1. **Syntax** — Strawman:
   ```mlld
   import signed { @noSecretExfil } from "@company/security"
   ```
   The `signed` keyword triggers verification before the import succeeds.
2. **What's signed** — The module source file? The exported symbols? The compiled/resolved form? Source file signing is simplest and matches how template signing works.
3. **Verification store** — Same `.mlld/sec/sigs/` directory? Separate namespace for modules vs templates?
4. **Registry modules** — For modules from the mlld registry, who signs? The publisher? mlld's registry infrastructure? Both (countersigning)?
5. **Local modules** — For `from "./lib/guards"`, signing is straightforward (developer signs at authoring time). For `from "@company/security"`, how is the signature distributed?
6. **Privilege escalation** — Should `import signed` be required for modules that export privileged guards? I.e., importing a privileged guard from an unsigned module is an error? This would make supply chain integrity mandatory for the most security-critical imports.
7. **Version pinning** — Signing a specific version. If the module updates, the old signature is invalid. How does this interact with semver resolution?
8. **Fallback behavior** — If verification fails: hard error, or warn-and-continue with guards downgraded to non-privileged?

## Deliverable

A spec section covering module signing workflow, verification semantics, registry integration, and interaction with the privilege system.

