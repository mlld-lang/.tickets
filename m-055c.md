---
id: m-055c
status: closed
deps: [m-2526]
links: []
created: 2026-02-23T05:55:04Z
type: feature
priority: 1
assignee: Adam
tags: [instructions, signing, taint]
updated: 2026-02-23T07:09:03Z
---
# Instructions category: cascading sign/verify with taint preservation

When instruction variables compose other variables, signing and verification must cascade while respecting trust boundaries.

**Example scenario:**
```mlld
exe @curl(website) = cmd { curl @website }
var untrusted @data = "something"
var @composed = "This is @data"
var inst @some = "Instruction part 1 with @data"
var inst @task = "Instruction part 2 with @curl("evil.com")"
var inst @list = "Instruction part 3 with @composed"
var inst @prompt = "Do @some @task @list"

@claude(@prompt)
```

**Key questions to resolve:**
1. When `@prompt` interpolates `@some`, `@task`, `@list` — does the composed result retain instruction status?
2. `@task` includes output from `@curl("evil.com")" — taint from net:r should propagate through
3. `@list` includes `@composed` which includes untrusted `@data` — taint should cascade
4. Verification of `@prompt` should verify the template shape (pre-interpolation), not the interpolated result
5. The verify tool should show the composition tree: which parts are signed instructions vs interpolated data

**Trust boundary rules:**
- `inst` variables are signed as instructions (template shape)
- Interpolated values carry their own taint/labels
- Composed instructions that include tainted data should still be verifiable as instructions
- The verify result should distinguish: these ARE the instructions (signed), this DATA was interpolated into them (possibly tainted)

**Depends on:** m-2526 (verify as MCP tool)


## Notes

**2026-02-23T06:00:44Z** Key insight from session: signature propagation should use the existing taint/label plumbing (inverse direction — provenance not taint). When @prompt interpolates signed @some, a provenance label like signed:some flows through interpolation alongside taint labels. The verify tool then just reads all signed:* provenance labels from the variable and batch-verifies them. No explicit tree-walking needed — the label propagation system already built the composition graph. This pairs naturally with immutable vars — the tree is stable by construction, so provenance labels are always accurate.

**2026-02-23T06:05:31Z** The airlock pattern (disreguard.com/blog) is Ring 3 defense that pairs with the instructions design. When an inst variable interpolates tainted data, provenance labels (signed:*) identify which parts are trusted instructions vs tainted data. This enables automatic airlock triggering: guard detects taint on an instruction variable → routes tainted content to extraction call (Call 1, mechanical summary only) → routes extraction + verified signed instructions to evaluation call (Call 2, clean room, no raw injection exposure) → gate is code (guard), not prompt. The provenance-through-taint-plumbing design gives the airlock exactly the metadata it needs to know what to separate.
