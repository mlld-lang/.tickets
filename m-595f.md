---
id: m-595f
status: closed
deps: []
created: 2026-02-10T21:40:57Z
type: bug
priority: 0
assignee: Adam
updated: 2026-02-12T21:49:56Z
---
# Imported function internal variables clash with caller-scope vars

When a function is imported from a module, its internal `let` variable names can clash with `var` declarations in the importing module. This is a runtime error (variable-redefinition) that the static validator does not catch.

Example: `context.mld` exports `@buildContext` which internally uses `let @descCountNum`. If `index.mld` imports `@buildContext` and also declares `var @descCountNum`, a runtime redefinition error occurs.

Same pattern as m-e084 (var name clashes with imported function params), but this is broader — it affects internal `let` bindings too, not just parameter names.

Repro:
1. Module A: `exe @fn(x) = [ let @foo = 1; => @foo ]` + `export { @fn }`
2. Module B: `import { @fn } from "./a.mld"` + `var @foo = 2` → runtime error

Impact: High friction for orchestrator authors. Every variable name must be globally unique across all imported function internals, which is invisible to the author. The validator should either catch this statically or the runtime should properly scope imported function internals.

## Acceptance Criteria

1. Static validator warns about potential name clashes between module-level vars and imported function internals
2. OR runtime properly isolates imported function internal scopes from the caller module scope


**2026-02-12 20:55 UTC:** Design decision: proper scope isolation for imported functions. Imported functions get their own scope frame; internal lets are invisible to the caller.

**2026-02-12 21:49 UTC:** Implemented module-isolation-aware variable owner lookup for let bindings so imported executable internals no longer collide with caller vars. Added regressions: tests/integration/import-exe-parameter-shadowing.test.ts (new internal-let case) and tests/cases/regression/import-exe-internal-let-shadowing. Ran full suite: npm test (pass). Commit: 676ec133f.
