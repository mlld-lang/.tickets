---
id: m-3800
status: closed
deps: [m-7c90]
links: []
created: 2026-02-09T06:24:52Z
type: task
priority: 1
assignee: Adam Avenir
parent: m-d11b
tags: [refactor, var, phase-7, tools]
updated: 2026-02-11T05:02:00Z
---
# Refactor Program: Modularize interpreter/eval/var.ts - Phase 7: Isolate tool-scope and tool-collection normalization

Objective:
Isolate tool-scope and tool-collection normalization logic.

Instructions for the implementing agent:
- Move tool helper functions into focused module(s) (example target: `interpreter/eval/var/tool-scope.ts`):
  - `resolveWithClauseToolsValue`
  - `normalizeToolScopeValue`
  - `enforceToolSubset`
  - `normalizeToolCollection`
  - related utility helpers (`resolveToolMlldName`, `normalizeStringArray`, `isPlainObject` if still tool-owned)
- Keep validation/error semantics stable, including parameter coverage checks for bind/expose.
- Ensure tool collection normalization still enforces executable reference constraints via environment lookups.
- Add focused tests for tool normalization success/failure scenarios and subset enforcement.

## Wave 2 Phase Guardrails

Required design constraints for this phase:
- Do not create runtime modules under 60 lines unless the file is a pure type-definition file or re-export barrel.
- Do not duplicate shared logic across sibling modules in this area; extract a shared helper/service when behavior overlaps.
- Do not introduce constructor callback-lambda injection as a service-composition strategy; use interface-typed service objects.
- Define shared result/context/types/type-guards once per extraction area and import them instead of re-declaring.
- Keep module dependency direction acyclic in the touched area before closing the phase.

Evidence required in the phase note before close:
- Touched runtime modules with line counts and a short ownership note per module.
- Targeted test commands run for this phase and pass/fail status.
- Explicit statement that no new sub-60 runtime module was introduced (or list allowed type/barrel exceptions).
- Explicit statement that no callback-lambda service injection was introduced (or justify a recursion-only exception).

## Acceptance Criteria

1. Tool-scope and tool-collection helpers are extracted into dedicated module(s).
2. Validation behavior and error semantics remain unchanged.
3. Added tests cover bind/expose validation and subset-enforcement scenarios.
4. Exit criteria: all tests pass, with output attached:
   npm run build && npm test && npm run test:tokens && npm run test:examples


**2026-02-11 05:01 UTC:** Phase 7 implementation complete.

What changed:
- Extracted tool-scope and tool-collection normalization logic into interpreter/eval/var/tool-scope.ts.
- Moved these helpers into the new module:
  - resolveWithClauseToolsValue
  - normalizeToolScopeValue
  - enforceToolSubset
  - normalizeToolCollection
  - related helpers (resolveToolMlldName, normalizeStringArray, isPlainObject)
- Updated interpreter/eval/var/execution-evaluator.ts to delegate tool-scope behavior to tool-scope.ts.
- Updated interpreter/eval/var.ts to delegate tool collection normalization to tool-scope.ts.
- Added focused unit tests in interpreter/eval/var/tool-scope.test.ts for normalization success/failure and subset enforcement scenarios.

Checklist completion:
- [x] Isolated tool-scope and tool-collection helper logic into dedicated module(s).
- [x] Preserved validation/error semantics for bind/expose and executable reference checks.
- [x] Preserved subset-enforcement behavior for NewExpression with tools scope.
- [x] Added focused tests for normalization and subset constraints.

Touched runtime modules and ownership:
- interpreter/eval/var/tool-scope.ts (220 lines): owns tool-scope parsing/enforcement, withClause.tools expression resolution, and tool collection normalization/validation.
- interpreter/eval/var/execution-evaluator.ts (247 lines): owns execution-branch orchestration and delegates tool-scope semantics to tool-scope.
- interpreter/eval/var.ts (383 lines): owns var orchestration and delegates tool collection normalization to tool-scope.

Targeted verification:
- npm run build -> PASS
- npx vitest run interpreter/eval/var/tool-scope.test.ts interpreter/eval/var/execution-evaluator.test.ts interpreter/eval/tools-collection.test.ts -> PASS
- npx vitest run interpreter/eval/var.characterization.test.ts tests/interpreter/security-metadata.test.ts interpreter/eval/run.structured.test.ts interpreter/eval/show.structured.test.ts -> PASS

Phase full-gate exit criteria:
- npm run build && npm test && npm run test:tokens && npm run test:examples -> PASS

Guardrail confirmations:
- No new runtime module under 60 lines was introduced.
- No callback-lambda service injection was introduced.
- Shared tool-scope behavior is centralized in a single module; no duplicated sibling logic introduced.
