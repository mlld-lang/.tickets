---
id: m-43a7
status: closed
deps: [m-e62f]
created: 2026-02-09T06:44:04Z
type: task
priority: 1
assignee: Adam Avenir
parent: m-bd66
tags: [refactor, run, phase-3]
updated: 2026-02-11T07:11:34Z
---
# Refactor Program: Modularize interpreter/eval/run.ts - Phase 3: Extract run-command execution orchestration

Objective:
Move runCommand execution flow into a dedicated module that owns command preparation, security checks, and execution wiring.

Instructions for the implementing agent:
- Extract the runCommand branch into a command executor module with a clear input/output contract.
- Include command source resolution (pre-extracted command vs interpolation), parsed-command metadata, and command-size pre-check.
- Include stdin resolution and descriptor handling for withClause.stdin.
- Include security-manager analyzer checks and policy checks in the extracted flow.
- Include working-directory resolution, environment/provider config resolution, auth/using merges, and provider-vs-local execution path.
- Preserve propagation of output descriptors and operation-context metadata.
- Add focused tests for command branch behavior, including provider path and command-size/security failures.

## Wave 2 Phase Guardrails

Required design constraints for this phase:
- Do not create runtime modules under 60 lines unless the file is a pure type-definition file or re-export barrel.
- Do not duplicate shared logic across sibling modules in this area; extract a shared helper/service when behavior overlaps.
- Do not introduce constructor callback-lambda injection as a service-composition strategy; use interface-typed service objects.
- Define shared result/context/types/type-guards once per extraction area and import them instead of re-declaring.
- Keep module dependency direction acyclic in the touched area before closing the phase.

Evidence required in the phase note before close:
- Touched runtime modules with line counts and a short ownership note per module.
- Targeted test commands run for this phase and pass/fail status.
- Explicit statement that no new sub-60 runtime module was introduced (or list allowed type/barrel exceptions).
- Explicit statement that no callback-lambda service injection was introduced (or justify a recursion-only exception).

## Acceptance Criteria

1. runCommand logic is extracted behind a dedicated orchestration API.
2. Existing command behaviors (including provider execution, stdin handling, security checks, and descriptor propagation) remain unchanged.
3. Focused tests cover command success and failure variants.
4. Exit criteria (required before next phase): full test gate passes with output attached:
   npm run build && npm test && npm run test:tokens && npm run test:examples


**2026-02-11 07:11 UTC:** Phase 3 extraction completed.

What changed:
- Extracted runCommand orchestration into `interpreter/eval/run-modules/run-command-executor.ts` (`executeRunCommand`).
- Moved command branch responsibilities into the module:
  - command source resolution (pre-extracted command vs interpolation)
  - operation-context command update + command policy check
  - argument/env-var extraction + label-flow checks
  - command-size guard
  - analyzer-based command security block
  - stdin resolution (`withClause.stdin` and pre-extracted stdin)
  - environment/provider auth+using wiring and provider-vs-local execution routing
  - output descriptor derivation for command execution
- Rewired `interpreter/eval/run.ts` to delegate runCommand branch to `executeRunCommand` and apply returned output descriptor.
- Added focused provider-path coverage in `interpreter/eval/run.characterization.test.ts` to assert provider execution is used and local execution is bypassed.

Touched runtime modules (ownership + line count):
- `interpreter/eval/run.ts` (1111 LOC): top-level run orchestrator; runCommand branch now delegates to command executor.
- `interpreter/eval/run-modules/run-command-executor.ts` (455 LOC): owns runCommand preparation, checks, and execution wiring.

Guardrail confirmations:
- No new runtime module under 60 LOC introduced.
- No callback-lambda service injection introduced.
- Shared helper usage stays centralized through existing run helper/policy modules.
- Module dependency direction remains acyclic in the touched run module area.

Sub-checkpoint evidence (pass):
- `npm run build && npx vitest run interpreter/eval/run.characterization.test.ts interpreter/eval/run.structured.test.ts interpreter/eval/run-in-blocks.test.ts tests/integration/policy-command-exec.test.ts tests/pipeline-context-retry.test.ts`

Full gate evidence (pass):
- `npm run build && npm test && npm run test:tokens && npm run test:examples`
