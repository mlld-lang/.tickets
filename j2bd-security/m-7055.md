---
id: m-7055
status: closed
deps: []
created: 2026-02-09T13:44:37Z
type: task
priority: 2
assignee: Adam Avenir
tags: [phase-2, urgency-high]
updated: 2026-02-09T14:01:34Z
---
# Implement dual-audit airlock demonstration

## Goal

Rewrite llm/run/j2bd/security/impl/main.mld to demonstrate the full dual-audit airlock pattern. Create the required prompt template files.

## Critical Constraints (from codebase investigation)

### 1. `guard privileged` syntax does NOT exist
The grammar (grammar/directives/guard.peggy) has no `privileged` keyword. Only policy-generated guards (from core/policy/guards.ts) are privileged. User-defined `guard` directives are NEVER privileged.

**Implication**: The dual-audit flow cannot use `guard privileged @dualAuditGate`. Instead:
- Use regular script flow for orchestration
- Policy rules provide the privileged enforcement (no-untrusted-destructive, etc.)
- User guards provide verification enforcement (ensureVerified)

### 2. Guards CANNOT orchestrate multi-step flows
Guards can only read @input/@output/@mx and return allow/deny/retry/env. They CANNOT:
- Call executables (`@someExe(@input)` in conditions)
- Bind results to variables (`=> @result`)
- Execute multi-step logic

**Implication**: The orchestration (call extract, call decide, check verdict, act on result) must happen in regular script flow, not inside a guard.

## Implementation Architecture

The dual-audit pattern works by composing existing mlld features:

```
Script Flow (orchestration)     Guards (enforcement)
─────────────────────────        ──────────────────────
1. Load & sign templates         autosign handles this
2. Call extract(@taintedData)    ensureVerified guard enforces verify
3. Call decide(@summary, @pol)   ensureVerified guard enforces verify  
4. Parse verdict                 (regular var/json)
5. Act on verdict                policy rules block tainted→destructive
   if safe: proceed (taint       
     was never on the summary)   
   if unsafe: show denial        
```

Key insight: Call 2's output is NOT tainted because call 2 never receives the original tainted data — it only receives the summary (which is the output of call 1, an LLM exe). The information bottleneck is structural.

## Files to Create/Modify

### 1. `llm/run/j2bd/security/impl/main.mld` (rewrite)

Structure:
- Policy config with autosign, autoverify, rules
- Enforcement guard (ensureVerified after llm)
- Two signed extraction/decision templates (loaded from .att files)
- Signed security policy document
- Mock LLM exes (exe llm using printf for deterministic output)
- Taint accumulation demo (var untrusted → exe llm → influenced)
- Dual-audit flow: extract → decide → act on verdict
- Adversarial demo: injection in tainted data

### 2. `llm/run/j2bd/security/impl/prompts/extract-instructions.att` (new)
Extraction template for call 1. Content from target example.

### 3. `llm/run/j2bd/security/impl/prompts/decide-safety.att` (new)
Decision template for call 2. Content from target example.

### 4. `llm/run/j2bd/security/impl/prompts/security-policy.att` (new)
The policy document that call 2 evaluates against.

### 5. Keep `llm/run/j2bd/security/impl/prompts/audit-criteria.att` (existing, for backward compat)

## Mock LLM Pattern

Use `exe llm @name(...) = run cmd { printf '...' }` for deterministic demo output. The mock exes simulate what real Claude calls would return. This is the same pattern used in the pattern-dual-audit atom.

## Important: What 'privileged' Means Here

The target example's `guard privileged @dualAuditGate` with `trusted! @input` is aspirational syntax. In the working implementation:
- Policy rules (no-untrusted-destructive) enforce that tainted data can't reach destructive ops
- The dual-audit flow happens BEFORE attempting the destructive op
- Call 2's output is naturally clean (never saw taint) so its verdict can gate the action
- The script uses if/when on the verdict to proceed or deny
- Non-privileged guards CANNOT remove protected labels — document this clearly

## Validation

Run `mlld validate llm/run/j2bd/security/impl/main.mld` to verify syntax.
Run the script to verify end-to-end execution.


**2026-02-09 14:01 UTC:** Friction reported: (1) guard @ensureVerified blocks all exe ops on llm-labeled data in standalone mode — solved by using plain exe mocks (architecturally correct). (2) var @x = template syntax is invalid — used <./path> instead. Both documented.
