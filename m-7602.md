---
id: m-7602
status: closed
deps: []
created: 2026-02-22T03:36:30Z
type: bug
priority: p0
assignee: Adam Avenir
updated: 2026-02-22T03:51:33Z
---
# run directive loses imported module scope â€” cross-module exe dependencies fail

## Bug

When calling an imported function via `run @fn(...)`, the function cannot resolve its own module's imports. The same call via `var @_ = @fn(...)` works fine.

## Repro

```mlld
>> file: lib.mld
import { @helper } from "./helper.mld"
exe @doWork(x) = [
  @helper(@x)   // <-- fails with "Command not found: helper" when called via `run`
  => @x
]
/export { @doWork }

>> file: main.mld
import { @doWork } from "./lib.mld"
run @doWork("test")        // FAILS: Command not found: helper
var @_ = @doWork("test")   // WORKS
```

Concrete case: `llm/run/qa/index.mld` line 91 calls `run @runFlail(...)`. The `@runFlail` function is imported from `phases/flail.mld`, which imports `@logPhaseStart` from `../lib/events.mld`. At runtime: "Command not found: logPhaseStart".

## Key observation

- `mlld validate --deep` passes
- `var @result = @fn(...)` works (function resolves its own module dependencies)
- `run @fn(...)` fails (function loses access to its module scope)

## Impact

All orchestrators that use `run @importedFn(...)` for side-effect-only calls. Workaround: use `var @_ = @fn(...)` instead, but this is ugly and shouldn't be necessary.

