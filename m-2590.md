---
id: m-2590
status: closed
deps: []
links: []
created: 2026-01-29T04:46:39Z
type: bug
priority: 0
assignee: Adam
tags: [interpreter, scoping, variables]
---
# Variable shadowing in nested scopes causes silent data corruption

When calling a function that uses a loop variable (e.g. @t), and the caller also uses @t in its loop, the inner function's @t clobbers the caller's. No warning is given. Example: `for @t in @tickets when \!@hasTag(@t, 'done')` breaks if @hasTag internally uses `for @t in @ticket.tags`.

## Root Cause

The bug is in `mergeChild` at `interpreter/env/Environment.ts:2486-2503`:

```typescript
mergeChild(child: Environment): void {
  for (const [name, variable] of child.variableManager.getVariables()) {
    const isLetBinding = variable.mx?.importPath === 'let';
    if (isLetBinding && this.variableManager.hasVariable(name)) {
      continue;  // Only skips if IMMEDIATE parent has it
    }
    this.variableManager.setVariable(name, variable);  // Clobbers!
  }
}
```

After evaluating an exe block (`interpreter/eval/exe.ts:87`), it calls `env.mergeChild(blockEnv)` which copies variables from child back to parent.

**The scenario:**
1. For loop creates child env with `@t`
2. Function called from loop creates child from for-loop's env
3. Function has `let @t = ...` - creates NEW variable (parent doesn't have it)
4. Function's exe block calls `mergeChild`
5. Since immediate parent doesn't have `@t` (it's in grandparent), skip check fails
6. `@t` gets merged up to for-loop's env, clobbering loop variable

## Fix

**Never merge let-bindings.** Let-bound variables are block-scoped by definition - they should never escape their block.

In `mergeChild`, change:
```typescript
if (isLetBinding && this.variableManager.hasVariable(name)) {
  continue;
}
```

To simply:
```typescript
if (isLetBinding) {
  continue;
}
```

Let bindings stay in their block. Period.

