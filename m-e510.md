---
id: m-e510
status: closed
deps: []
created: 2026-02-13T06:28:19Z
type: feature
priority: 1
assignee: Adam
tags: [developer-experience, namespace]
updated: 2026-02-27T04:51:39Z
---
# First-use-wins: allow user variables to shadow built-in transforms

Built-in transforms (@exists, @upper, @lower, @trim, @sort, @keep, @parse, @typeof, etc.) currently reserve their names — users get 'already defined' errors when trying to use common words as variable names.

Change to declarations-shadow-builtins semantics:
- User declarations always win: `var @exists = ..` shadows the builtin in that scope. The built-in @exists() is no longer available in that scope.
- If the user never declares the name, the builtin is available as normal.
- Shadowing is scope-local: child scopes can independently shadow or use the builtin.
- This applies to all built-in transforms and resolvers that occupy the global namespace.
- No temporal "first use" ordering — declarations shadow, period. This is how Python/JS handle built-in globals.

Not affected:
- @base, @root — path resolvers, stay reserved
- @mx — system namespace, stays reserved
- @input, @payload, @state — context variables, stay reserved (or handled separately)
- @debug, @pipeline — internal context, stay reserved

Implementation:
- interpreter/env/Environment.ts: change builtin registration from 'reserved' to 'shadowable'
- interpreter/env/VariableManager.ts: allow var/let declarations to mask shadowable builtins
- When a user shadows a builtin, the builtin becomes inaccessible in that scope
- Pipeline resolution (unified-processor.ts, builtin-transformers.ts): check scope variables BEFORE builtin names — user variable always wins over builtin detection
- Resolver lookup (Environment.ts, VariableManager.ts): update reserved-name membership checks to distinguish reserved vs shadowable
- mlld validate: informational warning when user shadows a builtin (not an error)
- cli/commands/analyze.ts: update reserved-name conflict detection to distinguish reserved vs shadowable

This replaces the original m-a310 motivation of moving builtins to @mx.* to avoid collisions. Shadowability solves the collision problem without namespace migration or added verbosity.

Related: m-9944 (closed — reserved names not documented), m-50a8 (closed — validate catches collisions)

Acceptance criteria:
- User can declare var @exists, var @upper, etc. without error
- User declarations shadow builtins in their scope
- Shadowed builtins are inaccessible in that scope
- Shadowing is scope-local — child scopes can independently shadow or use builtins
- In pipelines, user variables win over builtin detection
- mlld validate warns (informational) when shadowing occurs
- @base, @root, @mx remain truly reserved (cannot shadow)
- Full test suite passes

