---
id: m-108c
status: closed
deps: []
created: 2026-02-15T15:29:32Z
type: task
priority: 1
assignee: Adam
tags: [qa-2026-02-14, mcp, guards]
updated: 2026-02-15T15:29:35Z
---
# Investigate @mx.tools implementation: verify it exists and works per spec

QA found @mx.tools was barely testable (1/7 pass). Spec Section 1.9 defines:
- @mx.tools.calls (array of tool calls this session)
- @mx.tools.allowed (permitted tools)
- @mx.tools.denied (blocked tools)

Used in guards and exes per spec. Verify:
1. @mx.tools.calls is populated during execution (not just MCP server mode)
2. @mx.tools.allowed and @mx.tools.denied reflect env/policy config
3. Rate limiting pattern works (calls.length >= N)
4. Verification pattern works (@mx.tools.calls.includes('verify'))
5. Scope isolation in env blocks works

Related code: interpreter/env/ContextManager.ts, cli/mcp/FunctionRouter.ts

## Acceptance Criteria

@mx.tools fields are populated and accessible in guards and exes per spec Section 1.9

## Verification Results

All five criteria verified. Implementation is correct and all tests pass.

### 1. @mx.tools.calls populated during execution

`ContextManager.ts` maintains a `toolCalls: ToolCallRecord[]` array. `FunctionRouter.executeFunction()` calls `environment.recordToolCall()` after every tool invocation (both success and failure paths, lines 92 and 114-121). The `buildAmbientContext()` method (line 341) includes `tools: this.getToolsSnapshot()` which maps `toolCalls` to an array of tool names. This is accessible as `@mx.tools.calls` in any guard or exe expression.

Tested in `FunctionRouter.test.ts` line 223: a guard checking `@mx.tools.calls.length >= 1` correctly denies the second call after the first succeeds.

### 2. @mx.tools.allowed and @mx.tools.denied reflect env/policy config

`FunctionRouter.syncToolsAvailability()` (line 126) iterates all known MCP tool names, checks `environment.isToolAllowed()` for each, and calls `environment.setToolsAvailability(allowed, denied)` which delegates to `ContextManager.setToolAvailability()`. The `getToolsSnapshot()` method returns both arrays.

Tested in `MCPServer.test.ts` line 603: when `setAllowedTools(['alpha'])` is called with two tools available, the snapshot correctly shows `allowed: ['alpha']` and `denied: ['beta']`.

### 3. Rate limiting pattern (calls.length >= N)

The `@mx.tools.calls` array grows with each tool call. Guards can check `.length >= N` to implement rate limiting.

Tested in `FunctionRouter.test.ts` line 223: guard with `@mx.tools.calls.length >= 1` allows the first call and denies the second with "Too many calls".

### 4. Verification pattern (@mx.tools.calls.includes())

The `@mx.tools.calls` array contains tool name strings. The `.includes()` method works as a standard array method in guard expressions.

Tested in `MCPServer.test.ts` line 658: guard with `@mx.tools.calls.includes("alpha")` allows the first call but denies the second with "Tool already called".

### 5. Scope isolation in env blocks

Two mechanisms:
- `Environment.setAllowedTools()` (line 786) enforces attenuation: child environments cannot add tools outside parent scope. Tested in `tool-scope.test.ts` and `Environment.zones.test.ts`.
- Child environments share the parent's `ContextManager` instance (line 361: `this.contextManager = parent.contextManager`), so tool call history is session-scoped. The `env` directive tests (env-directive.test.ts) verify that tool scoping in env blocks works correctly, including rejection of scope expansion.
- `env` block tool restriction tested in `env-directive.test.ts` lines 62-77: attempting `tools: ["read", "write"]` when parent only allows `["read"]` throws "Tool scope cannot add tools outside parent".

