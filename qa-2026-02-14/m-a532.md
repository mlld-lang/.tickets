---
id: m-a532
status: closed
deps: []
created: 2026-02-15T15:27:19Z
type: feature
priority: 1
assignee: Adam
tags: [qa-2026-02-14, labels, guards, grammar]
updated: 2026-02-15T16:42:39Z
---
# Implement trusted!/!label/clear! shorthand syntax for label modification

Spec Section 4.3 defines shorthand syntax for privileged label operations:
- => trusted! @var (blessing: remove untrusted, add trusted)
- => !pii @var (remove specific label)
- => !pii,!internal @var (remove multiple labels)
- => clear! @var (remove all non-factual labels)

These don't parse currently. Workaround: allow with { addLabels, removeLabels } in guard actions.
Docs restored to show the intended syntax with a note about the current workaround.

## Acceptance Criteria

All four shorthand forms parse and execute correctly

## Resolution

Closed as duplicate of m-32d1, which fully investigated this.

The original ticket's premise ("these don't parse currently") was incorrect. All four shorthand forms already parse and are handled by the interpreter:

- **Grammar**: `ReturnLabelModifier` in `grammar/patterns/when-rhs-action.peggy` (lines 44-50) parses `trusted!` (kind: 'bless'), `!label` (kind: 'remove'), and `clear!` (kind: 'clear').
- **Interpreter**: `applyLabelModifiers` in `interpreter/eval/label-modification.ts` (lines 196-251) handles all three privileged kinds, gated by `requirePrivilege()` which checks `context.privileged === true`.

The architectural constraint is that the shorthand lives in `WhenRHSAction` grammar (used in exe/when blocks), but privilege only flows through guard evaluation context. Guards use their own `GuardAction` grammar with `allow with { addLabels, removeLabels }` syntax. There is no execution path where the privileged shorthand can succeed because exe/when blocks never have `privileged: true`.

m-32d1 already updated the docs (`docs/src/atoms/security/label-modification.md`) to accurately describe this: the shorthand is parsed and handled but privilege only flows through guard context which uses `allow with {}` syntax. Both syntactic forms are documented as equal options.

