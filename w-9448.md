---
id: w-9448
status: closed
deps: []
created: 2026-02-21T00:13:00Z
type: task
priority: 0
assignee: Adam
updated: 2026-02-24T14:01:00Z
---
# Design hero security example: guarded MCP tools concept

The guard-mcp-tools.mld example needs a complete rethink. Current version is confusing:

**Problems:**
1. The guard logic is silly ("no writes after web search" is not a real security concern)
2. Not clear what threat model this defends against
3. Doesn't show the power of the feature: MCP tools are untrusted sources, but you can label them and guard their usage
4. The env scoping pattern might not be the right way to demonstrate this

**What we're trying to show:**
- Import MCP tools (external, untrusted sources)
- Expose them to an LLM as mlld exes
- Label tools by risk category
- Guards enforce policy on tool usage based on labels + call history
- The LLM doesn't get to bypass the guards

**Core insight:**
You can give an LLM powerful tools (GitHub create/delete, filesystem access, etc.) but mlld's guard system ensures the LLM can't be tricked into misusing them via prompt injection. The guard operates at the execution layer, not the prompt layer.

**Need:**
A realistic, compelling example that shows:
- What data is tainted (src:mcp from tool responses)
- What operations are risky (destructive, exfil, write to shared systems)
- How guards prevent the exploit (even if LLM is fully compromised)

**Current hero example (hero-security.mld) for reference:**
Shows label propagation through transforms + policy blocking exfil. Works well for data flow. Need equivalent for tool call control.

## Acceptance Criteria

- Example shows realistic threat model
- Guard logic makes sense (not arbitrary)
- Clear what the LLM is trying to do vs what mlld prevents
- Demonstrates the value prop: safe tool use despite prompt injection
- Code validates and renders correctly

