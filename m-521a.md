---
id: m-521a
status: closed
deps: []
created: 2026-02-17T14:49:12Z
type: feature
priority: 0
assignee: Adam
tags: [for-parallel, error-handling, dx]
updated: 2026-02-17T17:43:44Z
---
# for-parallel canary: fail fast when first iteration errors

## Problem

`for parallel` silently swallows ALL errors, turning them into data objects. When the loop body has a systemic bug (wrong file paths, missing import, broken template), every iteration fails identically — but the script completes successfully with an empty or all-error result array and zero visible feedback.

Real-world example: an orchestrator script used `<@file>` to load files by paths from `cmd { grep ... }` output. The `cmd` paths were project-root-relative, but `<@file>` resolves from the script's directory. Every iteration silently errored. The script reported "Found 33 files to clean" then immediately "Strip-logs complete" with no work done, no warnings, no indication anything went wrong.

## Solution: canary iteration

Before dispatching the parallel batch, run the first qualifying iteration synchronously as a canary. If it errors, throw immediately (fail fast). If it succeeds, dispatch the remaining iterations with normal parallel error-swallowing behavior.

"First qualifying" means the first item that passes the `when` filter, if one is present. If index 0 is filtered out, the canary is whichever item first passes the filter.

### Behavior change

| Scenario | Current | After |
|---|---|---|
| First iteration errors | Silently swallowed, loop completes | **Throws** — script fails with visible error |
| Later iteration errors | Silently swallowed, becomes data object | Same (unchanged) |
| All iterations succeed | Normal | Same (unchanged) |
| Empty iterable | Returns [] | Same (unchanged) |

### Why first-only

- Systemic bugs (wrong paths, missing modules, bad templates) fail on every item. Catching the first one is sufficient.
- Data-specific errors (one weird file, transient network issue) happen on random items. These should still be swallowed so the batch completes.
- Running one canary adds negligible latency — it's one iteration before the pool starts.

## Implementation

### Files to change

- `interpreter/eval/for.ts` — both `evaluateForDirective` (~line 119-142) and `evaluateForExpression` (~line 232-255)

### Approach

In both the directive and expression forms:

1. Identify the first item that passes the `when` filter (if any)
2. Run that item's iteration body synchronously using the existing `runOne` function
3. If it throws (and it's not a bail error): **rethrow** instead of catching
4. If it succeeds: store its result, then dispatch remaining items via `runWithConcurrency` as normal
5. Combine the canary result with the batch results in the correct index position

### Key details

- The `when` filter evaluation must happen before the canary runs — extract the filter check from the `runOne` closure so it can be applied to find the canary item
- The canary uses the same `runOne` function, same environment setup, same context push/pop — no special code path for the iteration body itself
- `runWithConcurrency` already takes an array; just pass it `items.slice(1)` (post-filter) instead of the full array
- For the expression form (`ordered: true`), the canary result needs to be inserted at position 0 in the final results array
- Bail errors already propagate in both forms — no change needed there

### Edge cases

- Single-item iterable: the canary IS the only iteration. If it errors, throw. If it succeeds, return [result]. Equivalent to sequential behavior for 1 item.
- `when` filter eliminates all items: no canary, return empty. Same as current behavior.
- `when` filter eliminates index 0 but not index 1: index 1 is the canary.
- Canary succeeds but ALL remaining iterations error: normal behavior, errors become data objects. The user gets one good result and N-1 error objects.

## Acceptance criteria

- [ ] First parallel iteration that passes the `when` filter runs synchronously as a canary
- [ ] If canary errors, the error propagates (script fails with visible error message)
- [ ] If canary succeeds, remaining iterations run in parallel with normal error-swallowing
- [ ] Works for both directive form (`for parallel(N) @x in @list [...]`) and expression form (`var @r = for parallel(N) @x in @list [...]`)
- [ ] Bail errors still propagate regardless (no regression)
- [ ] Empty iterables still return [] (no regression)
- [ ] Existing parallel error-swallowing behavior unchanged for iterations after the canary
- [ ] Canary result appears at correct index in expression form results


**2026-02-17 17:43 UTC:** Implemented parallel canary fail-fast for for-directive and for-expression, respecting when filters; added regression tests in interpreter/eval/for.characterization.test.ts and adjusted parallel-block-outer-write fixture expectations; tests: npm test plus targeted vitest runs; commit bb56790a1.
